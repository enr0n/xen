// WARNING: This file has automatically been generated on Mon, 15 Jul 2019 11:58:01 EDT.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package libxl

/*
#cgo LDFLAGS: -L${SRCDIR}/../libxl -lxenlight
#include <libxl.h>
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *Ctx) Ref() *C.libxl_ctx {
	if x == nil {
		return nil
	}
	return (*C.libxl_ctx)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Ctx) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCtxRef converts the C object reference into a raw struct reference without wrapping.
func NewCtxRef(ref unsafe.Pointer) *Ctx {
	return (*Ctx)(ref)
}

// NewCtx allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCtx() *Ctx {
	return (*Ctx)(allocCtxMemory(1))
}

// allocCtxMemory allocates memory for type C.libxl_ctx in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCtxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCtxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCtxValue = unsafe.Sizeof([1]C.libxl_ctx{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Ctx) PassRef() *C.libxl_ctx {
	if x == nil {
		x = (*Ctx)(allocCtxMemory(1))
	}
	return (*C.libxl_ctx)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Defbool) Ref() *C.libxl_defbool {
	if x == nil {
		return nil
	}
	return (*C.libxl_defbool)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Defbool) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDefboolRef converts the C object reference into a raw struct reference without wrapping.
func NewDefboolRef(ref unsafe.Pointer) *Defbool {
	return (*Defbool)(ref)
}

// NewDefbool allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDefbool() *Defbool {
	return (*Defbool)(allocDefboolMemory(1))
}

// allocDefboolMemory allocates memory for type C.libxl_defbool in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDefboolMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDefboolValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDefboolValue = unsafe.Sizeof([1]C.libxl_defbool{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Defbool) PassRef() *C.libxl_defbool {
	if x == nil {
		x = (*Defbool)(allocDefboolMemory(1))
	}
	return (*C.libxl_defbool)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *AsyncopHow) Ref() *C.libxl_asyncop_how {
	if x == nil {
		return nil
	}
	return (*C.libxl_asyncop_how)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *AsyncopHow) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAsyncopHowRef converts the C object reference into a raw struct reference without wrapping.
func NewAsyncopHowRef(ref unsafe.Pointer) *AsyncopHow {
	return (*AsyncopHow)(ref)
}

// NewAsyncopHow allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewAsyncopHow() *AsyncopHow {
	return (*AsyncopHow)(allocAsyncopHowMemory(1))
}

// allocAsyncopHowMemory allocates memory for type C.libxl_asyncop_how in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAsyncopHowMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAsyncopHowValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAsyncopHowValue = unsafe.Sizeof([1]C.libxl_asyncop_how{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *AsyncopHow) PassRef() *C.libxl_asyncop_how {
	if x == nil {
		x = (*AsyncopHow)(allocAsyncopHowMemory(1))
	}
	return (*C.libxl_asyncop_how)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *AsyncprogressHow) Ref() *C.libxl_asyncprogress_how {
	if x == nil {
		return nil
	}
	return (*C.libxl_asyncprogress_how)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *AsyncprogressHow) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAsyncprogressHowRef converts the C object reference into a raw struct reference without wrapping.
func NewAsyncprogressHowRef(ref unsafe.Pointer) *AsyncprogressHow {
	return (*AsyncprogressHow)(ref)
}

// NewAsyncprogressHow allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewAsyncprogressHow() *AsyncprogressHow {
	return (*AsyncprogressHow)(allocAsyncprogressHowMemory(1))
}

// allocAsyncprogressHowMemory allocates memory for type C.libxl_asyncprogress_how in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAsyncprogressHowMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAsyncprogressHowValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAsyncprogressHowValue = unsafe.Sizeof([1]C.libxl_asyncprogress_how{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *AsyncprogressHow) PassRef() *C.libxl_asyncprogress_how {
	if x == nil {
		x = (*AsyncprogressHow)(allocAsyncprogressHowMemory(1))
	}
	return (*C.libxl_asyncprogress_how)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *XentoollogLogger) Ref() *C.xentoollog_logger {
	if x == nil {
		return nil
	}
	return (*C.xentoollog_logger)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *XentoollogLogger) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewXentoollogLoggerRef converts the C object reference into a raw struct reference without wrapping.
func NewXentoollogLoggerRef(ref unsafe.Pointer) *XentoollogLogger {
	return (*XentoollogLogger)(ref)
}

// NewXentoollogLogger allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewXentoollogLogger() *XentoollogLogger {
	return (*XentoollogLogger)(allocXentoollogLoggerMemory(1))
}

// allocXentoollogLoggerMemory allocates memory for type C.xentoollog_logger in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXentoollogLoggerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXentoollogLoggerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfXentoollogLoggerValue = unsafe.Sizeof([1]C.xentoollog_logger{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *XentoollogLogger) PassRef() *C.xentoollog_logger {
	if x == nil {
		x = (*XentoollogLogger)(allocXentoollogLoggerMemory(1))
	}
	return (*C.xentoollog_logger)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *XentoollogLoggerStdiostream) Ref() *C.xentoollog_logger_stdiostream {
	if x == nil {
		return nil
	}
	return (*C.xentoollog_logger_stdiostream)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *XentoollogLoggerStdiostream) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewXentoollogLoggerStdiostreamRef converts the C object reference into a raw struct reference without wrapping.
func NewXentoollogLoggerStdiostreamRef(ref unsafe.Pointer) *XentoollogLoggerStdiostream {
	return (*XentoollogLoggerStdiostream)(ref)
}

// NewXentoollogLoggerStdiostream allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewXentoollogLoggerStdiostream() *XentoollogLoggerStdiostream {
	return (*XentoollogLoggerStdiostream)(allocXentoollogLoggerStdiostreamMemory(1))
}

// allocXentoollogLoggerStdiostreamMemory allocates memory for type C.xentoollog_logger_stdiostream in C.
// The caller is responsible for freeing the this memory via C.free.
func allocXentoollogLoggerStdiostreamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfXentoollogLoggerStdiostreamValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfXentoollogLoggerStdiostreamValue = unsafe.Sizeof([1]C.xentoollog_logger_stdiostream{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *XentoollogLoggerStdiostream) PassRef() *C.xentoollog_logger_stdiostream {
	if x == nil {
		x = (*XentoollogLoggerStdiostream)(allocXentoollogLoggerStdiostreamMemory(1))
	}
	return (*C.xentoollog_logger_stdiostream)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *UUID) Ref() *C.libxl_uuid {
	if x == nil {
		return nil
	}
	return (*C.libxl_uuid)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *UUID) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewUUIDRef converts the C object reference into a raw struct reference without wrapping.
func NewUUIDRef(ref unsafe.Pointer) *UUID {
	return (*UUID)(ref)
}

// NewUUID allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewUUID() *UUID {
	return (*UUID)(allocUUIDMemory(1))
}

// allocUUIDMemory allocates memory for type C.libxl_uuid in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUUIDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUUIDValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUUIDValue = unsafe.Sizeof([1]C.libxl_uuid{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *UUID) PassRef() *C.libxl_uuid {
	if x == nil {
		x = (*UUID)(allocUUIDMemory(1))
	}
	return (*C.libxl_uuid)(unsafe.Pointer(x))
}

// allocDomInfoMemory allocates memory for type C.libxl_dominfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDomInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDomInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDomInfoValue = unsafe.Sizeof([1]C.libxl_dominfo{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DomInfo) Ref() *C.libxl_dominfo {
	if x == nil {
		return nil
	}
	return x.reff885823f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DomInfo) Free() {
	if x != nil && x.allocsf885823f != nil {
		x.allocsf885823f.(*cgoAllocMap).Free()
		x.reff885823f = nil
	}
}

// NewDomInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDomInfoRef(ref unsafe.Pointer) *DomInfo {
	if ref == nil {
		return nil
	}
	obj := new(DomInfo)
	obj.reff885823f = (*C.libxl_dominfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DomInfo) PassRef() (*C.libxl_dominfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff885823f != nil {
		return x.reff885823f, nil
	}
	memf885823f := allocDomInfoMemory(1)
	reff885823f := (*C.libxl_dominfo)(memf885823f)
	allocsf885823f := new(cgoAllocMap)
	allocsf885823f.Add(memf885823f)

	var cuuid_allocs *cgoAllocMap
	reff885823f.uuid, cuuid_allocs = *(*C.libxl_uuid)(unsafe.Pointer(&x.UUID)), cgoAllocsUnknown
	allocsf885823f.Borrow(cuuid_allocs)

	var cdomid_allocs *cgoAllocMap
	reff885823f.domid, cdomid_allocs = (C.libxl_domid)(x.DomID), cgoAllocsUnknown
	allocsf885823f.Borrow(cdomid_allocs)

	var cssidref_allocs *cgoAllocMap
	reff885823f.ssidref, cssidref_allocs = (C.uint32_t)(x.Ssidref), cgoAllocsUnknown
	allocsf885823f.Borrow(cssidref_allocs)

	var cssid_label_allocs *cgoAllocMap
	reff885823f.ssid_label, cssid_label_allocs = (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.SsidLabel)).Data)), cgoAllocsUnknown
	allocsf885823f.Borrow(cssid_label_allocs)

	var crunning_allocs *cgoAllocMap
	reff885823f.running, crunning_allocs = (C._Bool)(x.Running), cgoAllocsUnknown
	allocsf885823f.Borrow(crunning_allocs)

	var cblocked_allocs *cgoAllocMap
	reff885823f.blocked, cblocked_allocs = (C._Bool)(x.Blocked), cgoAllocsUnknown
	allocsf885823f.Borrow(cblocked_allocs)

	var cpaused_allocs *cgoAllocMap
	reff885823f.paused, cpaused_allocs = (C._Bool)(x.Paused), cgoAllocsUnknown
	allocsf885823f.Borrow(cpaused_allocs)

	var cshutdown_allocs *cgoAllocMap
	reff885823f.shutdown, cshutdown_allocs = (C._Bool)(x.Shutdown), cgoAllocsUnknown
	allocsf885823f.Borrow(cshutdown_allocs)

	var cdying_allocs *cgoAllocMap
	reff885823f.dying, cdying_allocs = (C._Bool)(x.Dying), cgoAllocsUnknown
	allocsf885823f.Borrow(cdying_allocs)

	var cnever_stop_allocs *cgoAllocMap
	reff885823f.never_stop, cnever_stop_allocs = (C._Bool)(x.NeverStop), cgoAllocsUnknown
	allocsf885823f.Borrow(cnever_stop_allocs)

	var coutstanding_memkb_allocs *cgoAllocMap
	reff885823f.outstanding_memkb, coutstanding_memkb_allocs = (C.uint64_t)(x.OutstandingMemkb), cgoAllocsUnknown
	allocsf885823f.Borrow(coutstanding_memkb_allocs)

	var ccurrent_memkb_allocs *cgoAllocMap
	reff885823f.current_memkb, ccurrent_memkb_allocs = (C.uint64_t)(x.CurrentMemkb), cgoAllocsUnknown
	allocsf885823f.Borrow(ccurrent_memkb_allocs)

	var cshared_memkb_allocs *cgoAllocMap
	reff885823f.shared_memkb, cshared_memkb_allocs = (C.uint64_t)(x.SharedMemkb), cgoAllocsUnknown
	allocsf885823f.Borrow(cshared_memkb_allocs)

	var cpaged_memkb_allocs *cgoAllocMap
	reff885823f.paged_memkb, cpaged_memkb_allocs = (C.uint64_t)(x.PagedMemkb), cgoAllocsUnknown
	allocsf885823f.Borrow(cpaged_memkb_allocs)

	var cmax_memkb_allocs *cgoAllocMap
	reff885823f.max_memkb, cmax_memkb_allocs = (C.uint64_t)(x.MaxMemkb), cgoAllocsUnknown
	allocsf885823f.Borrow(cmax_memkb_allocs)

	var ccpu_time_allocs *cgoAllocMap
	reff885823f.cpu_time, ccpu_time_allocs = (C.uint64_t)(x.CPUTime), cgoAllocsUnknown
	allocsf885823f.Borrow(ccpu_time_allocs)

	var cvcpu_max_id_allocs *cgoAllocMap
	reff885823f.vcpu_max_id, cvcpu_max_id_allocs = (C.uint32_t)(x.VCPUMaxId), cgoAllocsUnknown
	allocsf885823f.Borrow(cvcpu_max_id_allocs)

	var cvcpu_online_allocs *cgoAllocMap
	reff885823f.vcpu_online, cvcpu_online_allocs = (C.uint32_t)(x.VCPUOnline), cgoAllocsUnknown
	allocsf885823f.Borrow(cvcpu_online_allocs)

	var ccpupool_allocs *cgoAllocMap
	reff885823f.cpupool, ccpupool_allocs = (C.uint32_t)(x.CPUpool), cgoAllocsUnknown
	allocsf885823f.Borrow(ccpupool_allocs)

	var cdomain_type_allocs *cgoAllocMap
	reff885823f.domain_type, cdomain_type_allocs = (C.libxl_domain_type)(x.DomainType), cgoAllocsUnknown
	allocsf885823f.Borrow(cdomain_type_allocs)

	x.reff885823f = reff885823f
	x.allocsf885823f = allocsf885823f
	return reff885823f, allocsf885823f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DomInfo) PassValue() (C.libxl_dominfo, *cgoAllocMap) {
	if x.reff885823f != nil {
		return *x.reff885823f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DomInfo) Deref() {
	if x.reff885823f == nil {
		return
	}
	x.UUID = *(*UUID)(unsafe.Pointer(&x.reff885823f.uuid))
	x.DomID = (DomID)(x.reff885823f.domid)
	x.Ssidref = (Uint32T)(x.reff885823f.ssidref)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.SsidLabel))
	hxfc4425b.Data = unsafe.Pointer(x.reff885823f.ssid_label)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.Running = (bool)(x.reff885823f.running)
	x.Blocked = (bool)(x.reff885823f.blocked)
	x.Paused = (bool)(x.reff885823f.paused)
	x.Shutdown = (bool)(x.reff885823f.shutdown)
	x.Dying = (bool)(x.reff885823f.dying)
	x.NeverStop = (bool)(x.reff885823f.never_stop)
	x.OutstandingMemkb = (uint)(x.reff885823f.outstanding_memkb)
	x.CurrentMemkb = (uint)(x.reff885823f.current_memkb)
	x.SharedMemkb = (uint)(x.reff885823f.shared_memkb)
	x.PagedMemkb = (uint)(x.reff885823f.paged_memkb)
	x.MaxMemkb = (uint)(x.reff885823f.max_memkb)
	x.CPUTime = (uint)(x.reff885823f.cpu_time)
	x.VCPUMaxId = (Uint32T)(x.reff885823f.vcpu_max_id)
	x.VCPUOnline = (Uint32T)(x.reff885823f.vcpu_online)
	x.CPUpool = (Uint32T)(x.reff885823f.cpupool)
	x.DomainType = (DomainType)(x.reff885823f.domain_type)
}

// Ref returns a reference to C object as it is.
func (x *DomainCreateInfo) Ref() *C.libxl_domain_create_info {
	if x == nil {
		return nil
	}
	return (*C.libxl_domain_create_info)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DomainCreateInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDomainCreateInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewDomainCreateInfoRef(ref unsafe.Pointer) *DomainCreateInfo {
	return (*DomainCreateInfo)(ref)
}

// NewDomainCreateInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDomainCreateInfo() *DomainCreateInfo {
	return (*DomainCreateInfo)(allocDomainCreateInfoMemory(1))
}

// allocDomainCreateInfoMemory allocates memory for type C.libxl_domain_create_info in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDomainCreateInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDomainCreateInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDomainCreateInfoValue = unsafe.Sizeof([1]C.libxl_domain_create_info{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DomainCreateInfo) PassRef() *C.libxl_domain_create_info {
	if x == nil {
		x = (*DomainCreateInfo)(allocDomainCreateInfoMemory(1))
	}
	return (*C.libxl_domain_create_info)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DomainBuildInfo) Ref() *C.libxl_domain_build_info {
	if x == nil {
		return nil
	}
	return (*C.libxl_domain_build_info)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DomainBuildInfo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDomainBuildInfoRef converts the C object reference into a raw struct reference without wrapping.
func NewDomainBuildInfoRef(ref unsafe.Pointer) *DomainBuildInfo {
	return (*DomainBuildInfo)(ref)
}

// NewDomainBuildInfo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDomainBuildInfo() *DomainBuildInfo {
	return (*DomainBuildInfo)(allocDomainBuildInfoMemory(1))
}

// allocDomainBuildInfoMemory allocates memory for type C.libxl_domain_build_info in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDomainBuildInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDomainBuildInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDomainBuildInfoValue = unsafe.Sizeof([1]C.libxl_domain_build_info{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DomainBuildInfo) PassRef() *C.libxl_domain_build_info {
	if x == nil {
		x = (*DomainBuildInfo)(allocDomainBuildInfoMemory(1))
	}
	return (*C.libxl_domain_build_info)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceVfb) Ref() *C.libxl_device_vfb {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_vfb)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceVfb) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceVfbRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceVfbRef(ref unsafe.Pointer) *DeviceVfb {
	return (*DeviceVfb)(ref)
}

// NewDeviceVfb allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceVfb() *DeviceVfb {
	return (*DeviceVfb)(allocDeviceVfbMemory(1))
}

// allocDeviceVfbMemory allocates memory for type C.libxl_device_vfb in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceVfbMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceVfbValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceVfbValue = unsafe.Sizeof([1]C.libxl_device_vfb{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceVfb) PassRef() *C.libxl_device_vfb {
	if x == nil {
		x = (*DeviceVfb)(allocDeviceVfbMemory(1))
	}
	return (*C.libxl_device_vfb)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceVkb) Ref() *C.libxl_device_vkb {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_vkb)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceVkb) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceVkbRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceVkbRef(ref unsafe.Pointer) *DeviceVkb {
	return (*DeviceVkb)(ref)
}

// NewDeviceVkb allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceVkb() *DeviceVkb {
	return (*DeviceVkb)(allocDeviceVkbMemory(1))
}

// allocDeviceVkbMemory allocates memory for type C.libxl_device_vkb in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceVkbMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceVkbValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceVkbValue = unsafe.Sizeof([1]C.libxl_device_vkb{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceVkb) PassRef() *C.libxl_device_vkb {
	if x == nil {
		x = (*DeviceVkb)(allocDeviceVkbMemory(1))
	}
	return (*C.libxl_device_vkb)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceDisk) Ref() *C.libxl_device_disk {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_disk)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceDisk) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceDiskRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceDiskRef(ref unsafe.Pointer) *DeviceDisk {
	return (*DeviceDisk)(ref)
}

// NewDeviceDisk allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceDisk() *DeviceDisk {
	return (*DeviceDisk)(allocDeviceDiskMemory(1))
}

// allocDeviceDiskMemory allocates memory for type C.libxl_device_disk in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceDiskMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceDiskValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceDiskValue = unsafe.Sizeof([1]C.libxl_device_disk{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceDisk) PassRef() *C.libxl_device_disk {
	if x == nil {
		x = (*DeviceDisk)(allocDeviceDiskMemory(1))
	}
	return (*C.libxl_device_disk)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceNic) Ref() *C.libxl_device_nic {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_nic)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceNic) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceNicRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceNicRef(ref unsafe.Pointer) *DeviceNic {
	return (*DeviceNic)(ref)
}

// NewDeviceNic allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceNic() *DeviceNic {
	return (*DeviceNic)(allocDeviceNicMemory(1))
}

// allocDeviceNicMemory allocates memory for type C.libxl_device_nic in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceNicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceNicValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceNicValue = unsafe.Sizeof([1]C.libxl_device_nic{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceNic) PassRef() *C.libxl_device_nic {
	if x == nil {
		x = (*DeviceNic)(allocDeviceNicMemory(1))
	}
	return (*C.libxl_device_nic)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DevicePci) Ref() *C.libxl_device_pci {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_pci)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DevicePci) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDevicePciRef converts the C object reference into a raw struct reference without wrapping.
func NewDevicePciRef(ref unsafe.Pointer) *DevicePci {
	return (*DevicePci)(ref)
}

// NewDevicePci allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDevicePci() *DevicePci {
	return (*DevicePci)(allocDevicePciMemory(1))
}

// allocDevicePciMemory allocates memory for type C.libxl_device_pci in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDevicePciMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDevicePciValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDevicePciValue = unsafe.Sizeof([1]C.libxl_device_pci{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DevicePci) PassRef() *C.libxl_device_pci {
	if x == nil {
		x = (*DevicePci)(allocDevicePciMemory(1))
	}
	return (*C.libxl_device_pci)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceRdm) Ref() *C.libxl_device_rdm {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_rdm)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceRdm) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceRdmRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceRdmRef(ref unsafe.Pointer) *DeviceRdm {
	return (*DeviceRdm)(ref)
}

// NewDeviceRdm allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceRdm() *DeviceRdm {
	return (*DeviceRdm)(allocDeviceRdmMemory(1))
}

// allocDeviceRdmMemory allocates memory for type C.libxl_device_rdm in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceRdmMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceRdmValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceRdmValue = unsafe.Sizeof([1]C.libxl_device_rdm{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceRdm) PassRef() *C.libxl_device_rdm {
	if x == nil {
		x = (*DeviceRdm)(allocDeviceRdmMemory(1))
	}
	return (*C.libxl_device_rdm)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceUsbctrl) Ref() *C.libxl_device_usbctrl {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_usbctrl)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceUsbctrl) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceUsbctrlRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceUsbctrlRef(ref unsafe.Pointer) *DeviceUsbctrl {
	return (*DeviceUsbctrl)(ref)
}

// NewDeviceUsbctrl allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceUsbctrl() *DeviceUsbctrl {
	return (*DeviceUsbctrl)(allocDeviceUsbctrlMemory(1))
}

// allocDeviceUsbctrlMemory allocates memory for type C.libxl_device_usbctrl in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceUsbctrlMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceUsbctrlValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceUsbctrlValue = unsafe.Sizeof([1]C.libxl_device_usbctrl{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceUsbctrl) PassRef() *C.libxl_device_usbctrl {
	if x == nil {
		x = (*DeviceUsbctrl)(allocDeviceUsbctrlMemory(1))
	}
	return (*C.libxl_device_usbctrl)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceUsbdev) Ref() *C.libxl_device_usbdev {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_usbdev)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceUsbdev) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceUsbdevRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceUsbdevRef(ref unsafe.Pointer) *DeviceUsbdev {
	return (*DeviceUsbdev)(ref)
}

// NewDeviceUsbdev allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceUsbdev() *DeviceUsbdev {
	return (*DeviceUsbdev)(allocDeviceUsbdevMemory(1))
}

// allocDeviceUsbdevMemory allocates memory for type C.libxl_device_usbdev in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceUsbdevMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceUsbdevValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceUsbdevValue = unsafe.Sizeof([1]C.libxl_device_usbdev{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceUsbdev) PassRef() *C.libxl_device_usbdev {
	if x == nil {
		x = (*DeviceUsbdev)(allocDeviceUsbdevMemory(1))
	}
	return (*C.libxl_device_usbdev)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceDtdev) Ref() *C.libxl_device_dtdev {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_dtdev)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceDtdev) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceDtdevRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceDtdevRef(ref unsafe.Pointer) *DeviceDtdev {
	return (*DeviceDtdev)(ref)
}

// NewDeviceDtdev allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceDtdev() *DeviceDtdev {
	return (*DeviceDtdev)(allocDeviceDtdevMemory(1))
}

// allocDeviceDtdevMemory allocates memory for type C.libxl_device_dtdev in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceDtdevMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceDtdevValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceDtdevValue = unsafe.Sizeof([1]C.libxl_device_dtdev{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceDtdev) PassRef() *C.libxl_device_dtdev {
	if x == nil {
		x = (*DeviceDtdev)(allocDeviceDtdevMemory(1))
	}
	return (*C.libxl_device_dtdev)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceVtpm) Ref() *C.libxl_device_vtpm {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_vtpm)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceVtpm) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceVtpmRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceVtpmRef(ref unsafe.Pointer) *DeviceVtpm {
	return (*DeviceVtpm)(ref)
}

// NewDeviceVtpm allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceVtpm() *DeviceVtpm {
	return (*DeviceVtpm)(allocDeviceVtpmMemory(1))
}

// allocDeviceVtpmMemory allocates memory for type C.libxl_device_vtpm in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceVtpmMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceVtpmValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceVtpmValue = unsafe.Sizeof([1]C.libxl_device_vtpm{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceVtpm) PassRef() *C.libxl_device_vtpm {
	if x == nil {
		x = (*DeviceVtpm)(allocDeviceVtpmMemory(1))
	}
	return (*C.libxl_device_vtpm)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceP9) Ref() *C.libxl_device_p9 {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_p9)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceP9) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceP9Ref converts the C object reference into a raw struct reference without wrapping.
func NewDeviceP9Ref(ref unsafe.Pointer) *DeviceP9 {
	return (*DeviceP9)(ref)
}

// NewDeviceP9 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceP9() *DeviceP9 {
	return (*DeviceP9)(allocDeviceP9Memory(1))
}

// allocDeviceP9Memory allocates memory for type C.libxl_device_p9 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceP9Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceP9Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceP9Value = unsafe.Sizeof([1]C.libxl_device_p9{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceP9) PassRef() *C.libxl_device_p9 {
	if x == nil {
		x = (*DeviceP9)(allocDeviceP9Memory(1))
	}
	return (*C.libxl_device_p9)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DevicePvcallsif) Ref() *C.libxl_device_pvcallsif {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_pvcallsif)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DevicePvcallsif) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDevicePvcallsifRef converts the C object reference into a raw struct reference without wrapping.
func NewDevicePvcallsifRef(ref unsafe.Pointer) *DevicePvcallsif {
	return (*DevicePvcallsif)(ref)
}

// NewDevicePvcallsif allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDevicePvcallsif() *DevicePvcallsif {
	return (*DevicePvcallsif)(allocDevicePvcallsifMemory(1))
}

// allocDevicePvcallsifMemory allocates memory for type C.libxl_device_pvcallsif in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDevicePvcallsifMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDevicePvcallsifValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDevicePvcallsifValue = unsafe.Sizeof([1]C.libxl_device_pvcallsif{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DevicePvcallsif) PassRef() *C.libxl_device_pvcallsif {
	if x == nil {
		x = (*DevicePvcallsif)(allocDevicePvcallsifMemory(1))
	}
	return (*C.libxl_device_pvcallsif)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceChannel) Ref() *C.libxl_device_channel {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_channel)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceChannel) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceChannelRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceChannelRef(ref unsafe.Pointer) *DeviceChannel {
	return (*DeviceChannel)(ref)
}

// NewDeviceChannel allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceChannel() *DeviceChannel {
	return (*DeviceChannel)(allocDeviceChannelMemory(1))
}

// allocDeviceChannelMemory allocates memory for type C.libxl_device_channel in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceChannelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceChannelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceChannelValue = unsafe.Sizeof([1]C.libxl_device_channel{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceChannel) PassRef() *C.libxl_device_channel {
	if x == nil {
		x = (*DeviceChannel)(allocDeviceChannelMemory(1))
	}
	return (*C.libxl_device_channel)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceVdispl) Ref() *C.libxl_device_vdispl {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_vdispl)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceVdispl) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceVdisplRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceVdisplRef(ref unsafe.Pointer) *DeviceVdispl {
	return (*DeviceVdispl)(ref)
}

// NewDeviceVdispl allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceVdispl() *DeviceVdispl {
	return (*DeviceVdispl)(allocDeviceVdisplMemory(1))
}

// allocDeviceVdisplMemory allocates memory for type C.libxl_device_vdispl in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceVdisplMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceVdisplValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceVdisplValue = unsafe.Sizeof([1]C.libxl_device_vdispl{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceVdispl) PassRef() *C.libxl_device_vdispl {
	if x == nil {
		x = (*DeviceVdispl)(allocDeviceVdisplMemory(1))
	}
	return (*C.libxl_device_vdispl)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DeviceVsnd) Ref() *C.libxl_device_vsnd {
	if x == nil {
		return nil
	}
	return (*C.libxl_device_vsnd)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DeviceVsnd) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDeviceVsndRef converts the C object reference into a raw struct reference without wrapping.
func NewDeviceVsndRef(ref unsafe.Pointer) *DeviceVsnd {
	return (*DeviceVsnd)(ref)
}

// NewDeviceVsnd allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDeviceVsnd() *DeviceVsnd {
	return (*DeviceVsnd)(allocDeviceVsndMemory(1))
}

// allocDeviceVsndMemory allocates memory for type C.libxl_device_vsnd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDeviceVsndMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDeviceVsndValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDeviceVsndValue = unsafe.Sizeof([1]C.libxl_device_vsnd{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DeviceVsnd) PassRef() *C.libxl_device_vsnd {
	if x == nil {
		x = (*DeviceVsnd)(allocDeviceVsndMemory(1))
	}
	return (*C.libxl_device_vsnd)(unsafe.Pointer(x))
}

// allocDomainConfigMemory allocates memory for type C.libxl_domain_config in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDomainConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfDomainConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfDomainConfigValue = unsafe.Sizeof([1]C.libxl_domain_config{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DomainConfig) Ref() *C.libxl_domain_config {
	if x == nil {
		return nil
	}
	return x.ref87e08e4d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DomainConfig) Free() {
	if x != nil && x.allocs87e08e4d != nil {
		x.allocs87e08e4d.(*cgoAllocMap).Free()
		x.ref87e08e4d = nil
	}
}

// NewDomainConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDomainConfigRef(ref unsafe.Pointer) *DomainConfig {
	if ref == nil {
		return nil
	}
	obj := new(DomainConfig)
	obj.ref87e08e4d = (*C.libxl_domain_config)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DomainConfig) PassRef() (*C.libxl_domain_config, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87e08e4d != nil {
		return x.ref87e08e4d, nil
	}
	mem87e08e4d := allocDomainConfigMemory(1)
	ref87e08e4d := (*C.libxl_domain_config)(mem87e08e4d)
	allocs87e08e4d := new(cgoAllocMap)
	allocs87e08e4d.Add(mem87e08e4d)

	var cc_info_allocs *cgoAllocMap
	ref87e08e4d.c_info, cc_info_allocs = *(*C.libxl_domain_create_info)(unsafe.Pointer(&x.CInfo)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cc_info_allocs)

	var cb_info_allocs *cgoAllocMap
	ref87e08e4d.b_info, cb_info_allocs = *(*C.libxl_domain_build_info)(unsafe.Pointer(&x.BInfo)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cb_info_allocs)

	var cnum_disks_allocs *cgoAllocMap
	ref87e08e4d.num_disks, cnum_disks_allocs = (C.int)(x.NumDisks), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_disks_allocs)

	var cdisks_allocs *cgoAllocMap
	ref87e08e4d.disks, cdisks_allocs = *(**C.libxl_device_disk)(unsafe.Pointer(&x.Disks)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cdisks_allocs)

	var cnum_nics_allocs *cgoAllocMap
	ref87e08e4d.num_nics, cnum_nics_allocs = (C.int)(x.NumNics), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_nics_allocs)

	var cnics_allocs *cgoAllocMap
	ref87e08e4d.nics, cnics_allocs = *(**C.libxl_device_nic)(unsafe.Pointer(&x.Nics)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnics_allocs)

	var cnum_pcidevs_allocs *cgoAllocMap
	ref87e08e4d.num_pcidevs, cnum_pcidevs_allocs = (C.int)(x.NumPcidevs), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_pcidevs_allocs)

	var cpcidevs_allocs *cgoAllocMap
	ref87e08e4d.pcidevs, cpcidevs_allocs = *(**C.libxl_device_pci)(unsafe.Pointer(&x.Pcidevs)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cpcidevs_allocs)

	var cnum_rdms_allocs *cgoAllocMap
	ref87e08e4d.num_rdms, cnum_rdms_allocs = (C.int)(x.NumRdms), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_rdms_allocs)

	var crdms_allocs *cgoAllocMap
	ref87e08e4d.rdms, crdms_allocs = *(**C.libxl_device_rdm)(unsafe.Pointer(&x.Rdms)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(crdms_allocs)

	var cnum_dtdevs_allocs *cgoAllocMap
	ref87e08e4d.num_dtdevs, cnum_dtdevs_allocs = (C.int)(x.NumDtdevs), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_dtdevs_allocs)

	var cdtdevs_allocs *cgoAllocMap
	ref87e08e4d.dtdevs, cdtdevs_allocs = *(**C.libxl_device_dtdev)(unsafe.Pointer(&x.Dtdevs)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cdtdevs_allocs)

	var cnum_vfbs_allocs *cgoAllocMap
	ref87e08e4d.num_vfbs, cnum_vfbs_allocs = (C.int)(x.NumVfbs), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_vfbs_allocs)

	var cvfbs_allocs *cgoAllocMap
	ref87e08e4d.vfbs, cvfbs_allocs = *(**C.libxl_device_vfb)(unsafe.Pointer(&x.Vfbs)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cvfbs_allocs)

	var cnum_vkbs_allocs *cgoAllocMap
	ref87e08e4d.num_vkbs, cnum_vkbs_allocs = (C.int)(x.NumVkbs), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_vkbs_allocs)

	var cvkbs_allocs *cgoAllocMap
	ref87e08e4d.vkbs, cvkbs_allocs = *(**C.libxl_device_vkb)(unsafe.Pointer(&x.Vkbs)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cvkbs_allocs)

	var cnum_vtpms_allocs *cgoAllocMap
	ref87e08e4d.num_vtpms, cnum_vtpms_allocs = (C.int)(x.NumVtpms), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_vtpms_allocs)

	var cvtpms_allocs *cgoAllocMap
	ref87e08e4d.vtpms, cvtpms_allocs = *(**C.libxl_device_vtpm)(unsafe.Pointer(&x.Vtpms)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cvtpms_allocs)

	var cnum_p9s_allocs *cgoAllocMap
	ref87e08e4d.num_p9s, cnum_p9s_allocs = (C.int)(x.NumP9s), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_p9s_allocs)

	var cp9s_allocs *cgoAllocMap
	ref87e08e4d.p9s, cp9s_allocs = *(**C.libxl_device_p9)(unsafe.Pointer(&x.P9s)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cp9s_allocs)

	var cnum_pvcallsifs_allocs *cgoAllocMap
	ref87e08e4d.num_pvcallsifs, cnum_pvcallsifs_allocs = (C.int)(x.NumPvcallsifs), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_pvcallsifs_allocs)

	var cpvcallsifs_allocs *cgoAllocMap
	ref87e08e4d.pvcallsifs, cpvcallsifs_allocs = *(**C.libxl_device_pvcallsif)(unsafe.Pointer(&x.Pvcallsifs)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cpvcallsifs_allocs)

	var cnum_vdispls_allocs *cgoAllocMap
	ref87e08e4d.num_vdispls, cnum_vdispls_allocs = (C.int)(x.NumVdispls), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_vdispls_allocs)

	var cvdispls_allocs *cgoAllocMap
	ref87e08e4d.vdispls, cvdispls_allocs = *(**C.libxl_device_vdispl)(unsafe.Pointer(&x.Vdispls)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cvdispls_allocs)

	var cnum_vsnds_allocs *cgoAllocMap
	ref87e08e4d.num_vsnds, cnum_vsnds_allocs = (C.int)(x.NumVsnds), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_vsnds_allocs)

	var cvsnds_allocs *cgoAllocMap
	ref87e08e4d.vsnds, cvsnds_allocs = *(**C.libxl_device_vsnd)(unsafe.Pointer(&x.Vsnds)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cvsnds_allocs)

	var cnum_channels_allocs *cgoAllocMap
	ref87e08e4d.num_channels, cnum_channels_allocs = (C.int)(x.NumChannels), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_channels_allocs)

	var cchannels_allocs *cgoAllocMap
	ref87e08e4d.channels, cchannels_allocs = *(**C.libxl_device_channel)(unsafe.Pointer(&x.Channels)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cchannels_allocs)

	var cnum_usbctrls_allocs *cgoAllocMap
	ref87e08e4d.num_usbctrls, cnum_usbctrls_allocs = (C.int)(x.NumUsbctrls), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_usbctrls_allocs)

	var cusbctrls_allocs *cgoAllocMap
	ref87e08e4d.usbctrls, cusbctrls_allocs = *(**C.libxl_device_usbctrl)(unsafe.Pointer(&x.Usbctrls)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cusbctrls_allocs)

	var cnum_usbdevs_allocs *cgoAllocMap
	ref87e08e4d.num_usbdevs, cnum_usbdevs_allocs = (C.int)(x.NumUsbdevs), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cnum_usbdevs_allocs)

	var cusbdevs_allocs *cgoAllocMap
	ref87e08e4d.usbdevs, cusbdevs_allocs = *(**C.libxl_device_usbdev)(unsafe.Pointer(&x.Usbdevs)), cgoAllocsUnknown
	allocs87e08e4d.Borrow(cusbdevs_allocs)

	var con_poweroff_allocs *cgoAllocMap
	ref87e08e4d.on_poweroff, con_poweroff_allocs = (C.libxl_action_on_shutdown)(x.OnPoweroff), cgoAllocsUnknown
	allocs87e08e4d.Borrow(con_poweroff_allocs)

	var con_reboot_allocs *cgoAllocMap
	ref87e08e4d.on_reboot, con_reboot_allocs = (C.libxl_action_on_shutdown)(x.OnReboot), cgoAllocsUnknown
	allocs87e08e4d.Borrow(con_reboot_allocs)

	var con_watchdog_allocs *cgoAllocMap
	ref87e08e4d.on_watchdog, con_watchdog_allocs = (C.libxl_action_on_shutdown)(x.OnWatchdog), cgoAllocsUnknown
	allocs87e08e4d.Borrow(con_watchdog_allocs)

	var con_crash_allocs *cgoAllocMap
	ref87e08e4d.on_crash, con_crash_allocs = (C.libxl_action_on_shutdown)(x.OnCrash), cgoAllocsUnknown
	allocs87e08e4d.Borrow(con_crash_allocs)

	var con_soft_reset_allocs *cgoAllocMap
	ref87e08e4d.on_soft_reset, con_soft_reset_allocs = (C.libxl_action_on_shutdown)(x.OnSoftReset), cgoAllocsUnknown
	allocs87e08e4d.Borrow(con_soft_reset_allocs)

	x.ref87e08e4d = ref87e08e4d
	x.allocs87e08e4d = allocs87e08e4d
	return ref87e08e4d, allocs87e08e4d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DomainConfig) PassValue() (C.libxl_domain_config, *cgoAllocMap) {
	if x.ref87e08e4d != nil {
		return *x.ref87e08e4d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DomainConfig) Deref() {
	if x.ref87e08e4d == nil {
		return
	}
	x.CInfo = *(*DomainCreateInfo)(unsafe.Pointer(&x.ref87e08e4d.c_info))
	x.BInfo = *(*DomainBuildInfo)(unsafe.Pointer(&x.ref87e08e4d.b_info))
	x.NumDisks = (int32)(x.ref87e08e4d.num_disks)
	x.Disks = (*DeviceDisk)(unsafe.Pointer(x.ref87e08e4d.disks))
	x.NumNics = (int32)(x.ref87e08e4d.num_nics)
	x.Nics = (*DeviceNic)(unsafe.Pointer(x.ref87e08e4d.nics))
	x.NumPcidevs = (int32)(x.ref87e08e4d.num_pcidevs)
	x.Pcidevs = (*DevicePci)(unsafe.Pointer(x.ref87e08e4d.pcidevs))
	x.NumRdms = (int32)(x.ref87e08e4d.num_rdms)
	x.Rdms = (*DeviceRdm)(unsafe.Pointer(x.ref87e08e4d.rdms))
	x.NumDtdevs = (int32)(x.ref87e08e4d.num_dtdevs)
	x.Dtdevs = (*DeviceDtdev)(unsafe.Pointer(x.ref87e08e4d.dtdevs))
	x.NumVfbs = (int32)(x.ref87e08e4d.num_vfbs)
	x.Vfbs = (*DeviceVfb)(unsafe.Pointer(x.ref87e08e4d.vfbs))
	x.NumVkbs = (int32)(x.ref87e08e4d.num_vkbs)
	x.Vkbs = (*DeviceVkb)(unsafe.Pointer(x.ref87e08e4d.vkbs))
	x.NumVtpms = (int32)(x.ref87e08e4d.num_vtpms)
	x.Vtpms = (*DeviceVtpm)(unsafe.Pointer(x.ref87e08e4d.vtpms))
	x.NumP9s = (int32)(x.ref87e08e4d.num_p9s)
	x.P9s = (*DeviceP9)(unsafe.Pointer(x.ref87e08e4d.p9s))
	x.NumPvcallsifs = (int32)(x.ref87e08e4d.num_pvcallsifs)
	x.Pvcallsifs = (*DevicePvcallsif)(unsafe.Pointer(x.ref87e08e4d.pvcallsifs))
	x.NumVdispls = (int32)(x.ref87e08e4d.num_vdispls)
	x.Vdispls = (*DeviceVdispl)(unsafe.Pointer(x.ref87e08e4d.vdispls))
	x.NumVsnds = (int32)(x.ref87e08e4d.num_vsnds)
	x.Vsnds = (*DeviceVsnd)(unsafe.Pointer(x.ref87e08e4d.vsnds))
	x.NumChannels = (int32)(x.ref87e08e4d.num_channels)
	x.Channels = (*DeviceChannel)(unsafe.Pointer(x.ref87e08e4d.channels))
	x.NumUsbctrls = (int32)(x.ref87e08e4d.num_usbctrls)
	x.Usbctrls = (*DeviceUsbctrl)(unsafe.Pointer(x.ref87e08e4d.usbctrls))
	x.NumUsbdevs = (int32)(x.ref87e08e4d.num_usbdevs)
	x.Usbdevs = (*DeviceUsbdev)(unsafe.Pointer(x.ref87e08e4d.usbdevs))
	x.OnPoweroff = (ActionOnShutdown)(x.ref87e08e4d.on_poweroff)
	x.OnReboot = (ActionOnShutdown)(x.ref87e08e4d.on_reboot)
	x.OnWatchdog = (ActionOnShutdown)(x.ref87e08e4d.on_watchdog)
	x.OnCrash = (ActionOnShutdown)(x.ref87e08e4d.on_crash)
	x.OnSoftReset = (ActionOnShutdown)(x.ref87e08e4d.on_soft_reset)
}
